; MCS51 Assembler Version 4.1.4 vom 10. 08. 03, A. Roth Controllertechnik, 9. August 2022
				1:1	; 09.08.2022 18:16:32
				1:2	
				1:3	#cpu = 89S8252	; @12 MHz
				1:4	
				1:5	#use LCALL
				1:6	
0000	01	0D		1:7	ajmp Initialisierung
				1:8	
000B				1:9	Timer 0:	; Timer 0 Interrupt
000B	01	54		1:10		ajmp OnTick
				1:11	
000D				1:12	Initialisierung:
000D	43	89	02	1:13	orl TMOD, # 02h	; Timer 0 im 8-Bit Autoreload-Modus. 
				1:14	; Die Überlauffrequenz des Timer 0 beträgt 4000 Hz, die Periodendauer 0,25 ms.
0010	75	8C	06	1:15	mov TH0, # 06h	; Reloadwert
				1:16	
				1:17	; Interrupts
0013	D2	A9		1:18	setb ET0	; Timer 0 Interrupt freigeben
0015	D2	AF		1:19	setb EA	; globale Interruptfreigabe
0017	D2	8C		1:20	setb TR0 ;Timer 0 läuft
				1:21	
				1:22	; reset clock tick counter
0019	12	00	F6	1:23	lcall ResetClockTicks
				1:24	
				1:25	;initialize_array
001C	75	40	00	1:26	mov 40h, #0h
001F	75	41	00	1:27	mov 41h, #0h
0022	75	42	00	1:28	mov 42h, #0h
0025	75	43	00	1:29	mov 43h, #0h
0028	75	44	00	1:30	mov 44h, #0h
002B	75	45	00	1:31	mov 45h, #0h
002E	75	46	00	1:32	mov 46h, #0h
0031	75	47	00	1:33	mov 47h, #0h
0034	75	48	00	1:34	mov 48h, #0h
0037	75	49	00	1:35	mov 49h, #0h
				1:36	
				1:37	;initialize_seconds
003A	90	01	1F	1:38	mov DPTR, #_seconds
003D	12	01	19	1:39	lcall LoadVariable
0040	76	00		1:40	mov @r0, #0h
				1:41	
				1:42	;initialize_pointer
0042	90	01	21	1:43	mov DPTR, #_pointer
0045	12	01	19	1:44	lcall LoadVariable
0048	76	40		1:45	mov @r0, #40h
				1:46	
				1:47	;initialize_average
004A	90	01	23	1:48	mov DPTR, #_average
004D	12	01	19	1:49	lcall LoadVariable
0050	76	00		1:50	mov @r0, #0h
				1:51	
0052	80	FE		1:52	end
				1:53	; * * * Hauptprogramm Ende * * *
				1:54	
0054				1:55	OnTick:
				1:56		; check if _clock_ticks is 0
0054	90	01	20	1:57		mov DPTR, #_clock_ticks		; load clock_ticks** to dptr
0057	12	01	19	1:58		lcall LoadVariable			; load clock_ticks* to r0
005A	E6			1:59		mov A, @r0					; load clock_ticks low byte to A
005B	08			1:60		inc r0						; increment clock_ticks* to target high byte
005C	46			1:61		orl A, @r0					; Low byte OR high byte to A
005D	70	06		1:62		jnz __OnTick_End			; if clock_ticks is not 0, jump to OnTick_End
				1:63		; clock_ticks is 0 (a second has passed)
				1:64		; reset _clock_ticks to 4000
005F	12	00	F6	1:65		lcall ResetClockTicks
				1:66		; increment _seconds
0062	12	00	6C	1:67		lcall DoAfterTenSeconds
0065				1:68	__OnTick_End:
				1:69		; decrement _clock_ticks
0065	90	01	20	1:70		mov DPTR, #_clock_ticks		; load clock_ticks** to dptr
0068	12	01	0C	1:71		lcall DecrementWord			; decrement clock_ticks by 1
006B	32			1:72		reti
				1:73		
006C				1:74	DoAfterTenSeconds:
				1:75		; logic for reading from P2 and writing to address that the _pointer is pointing to
006C	90	01	21	1:76		mov DPTR, #_pointer
006F	12	01	19	1:77		lcall LoadVariable
0072	E6			1:78		mov A, @r0
0073	C9			1:79		xch A, r1
0074	A7	A0		1:80		mov @r1, P2
0076	12	00	84	1:81		lcall CalculateAverage
0079	74	49		1:82		mov A, #49h	
007B	66			1:83		XRL A, @r0
007C	70	03		1:84		jnz __DoAfterTenSeconds_End ; if _pointer is not pointing at RAM Address 49h, skip below logic
				1:85		; logic when pointer was at last address (49h)
007E	75	4B	3F	1:86		mov 4Bh, #3Fh
0081				1:87	__DoAfterTenSeconds_End:
0081	05	4B		1:88		inc 4Bh
0083	22			1:89		ret
				1:90		
0084				1:91	CalculateAverage:
0084	75	F0	0A	1:92		mov B, #10d
0087	79	00		1:93		mov r1, #0
0089	AA	4A		1:94		mov r2, 4Ah
008B	E4			1:95		clr A
				1:96	
008C	C9			1:97		xch A, r1
008D	E5	40		1:98		mov A, 40h
008F	84			1:99		div AB
0090	75	F0	0A	1:100		mov B, #10
				1:101		
0093	29			1:102		add A, r1
0094	C9			1:103		xch A, r1
0095	E5	41		1:104		mov A, 41h
0097	75	F0	0A	1:105		mov B, #10	
009A	84			1:106		div AB
009B	29			1:107		add A, r1
009C	C9			1:108		xch A, r1
009D	E5	42		1:109		mov A, 42h
009F	75	F0	0A	1:110		mov B, #10
00A2	84			1:111		div AB
00A3	29			1:112		add A, r1
00A4	C9			1:113		xch A, r1
00A5	E5	43		1:114		mov A, 43h
00A7	75	F0	0A	1:115		mov B, #10
00AA	84			1:116		div AB
00AB	29			1:117		add A, r1
00AC	C9			1:118		xch A, r1
00AD	E5	44		1:119		mov A, 44h
00AF	75	F0	0A	1:120		mov B, #10
00B2	84			1:121		div AB
00B3	29			1:122		add A, r1
00B4	C9			1:123		xch A, r1
00B5	E5	45		1:124		mov A, 45h
00B7	75	F0	0A	1:125		mov B, #10
00BA	84			1:126		div AB
00BB	29			1:127		add A, r1
00BC	C9			1:128		xch A, r1
00BD	E5	46		1:129		mov A, 46h
00BF	75	F0	0A	1:130		mov B, #10
00C2	84			1:131		div AB
00C3	29			1:132		add A, r1
00C4	C9			1:133		xch A, r1
00C5	E5	47		1:134		mov A, 47h
00C7	75	F0	0A	1:135		mov B, #10
00CA	84			1:136		div AB
00CB	29			1:137		add A, r1
00CC	C9			1:138		xch A, r1
00CD	E5	48		1:139		mov A, 48h
00CF	75	F0	0A	1:140		mov B, #10
00D2	84			1:141		div AB
00D3	29			1:142		add A, r1
00D4	C9			1:143		xch A, r1
00D5	E5	49		1:144		mov A, 49h
00D7	75	F0	0A	1:145		mov B, #10
00DA	84			1:146		div AB
00DB	29			1:147		add A, r1
00DC	90	01	23	1:148		mov DPTR, #_average
00DF	12	01	19	1:149		lcall LoadVariable
00E2	F6			1:150		mov @r0, A
00E3	12	00	E7	1:151		lcall CompareAverages
00E6	22			1:152		ret
				1:153	
00E7				1:154	CompareAverages:
00E7	E5	4A		1:155		mov A, 4Ah
00E9	8A	F0		1:156		mov B, r2
00EB	84			1:157		div AB
00EC	60	04		1:158		jz __CompareAverages_Zero
00EE	75	4D	01	1:159		mov 4Dh, #1d
00F1	22			1:160		ret
				1:161		; if value at RAM Address 4Dh is 0 => new average was lower than previous || 1 => new average was equal or greater than old average
00F2				1:162	__CompareAverages_Zero:
00F2	75	4D	00	1:163		mov 4Dh, #0d	
00F5	22			1:164		ret
				1:165		
				1:166	; set clock ticks to 40000d
00F6				1:167	ResetClockTicks:
00F6	90	01	20	1:168		mov DPTR, #_clock_ticks
00F9	7A	0F		1:169		mov r2, #0Fh
00FB	7B	A0		1:170		mov r3, #A0h
				1:171		;mov r2, #9Ch; high byte of target value 0x0FA0 (40000)
				1:172		;mov r3, #40h; low byte of target value 0x0FA0 (40000)
00FD	12	01	01	1:173		lcall SetWord
0100	22			1:174		ret
				1:175		
				1:176	; the address of target LE 16bit integer is stored in DPTR
				1:177	; high byte of target value is stored in r2
				1:178	; low byte of target value is stored in r3
0101				1:179	SetWord:
0101	12	01	19	1:180		lcall LoadVariable		; load address of variable to r0
0104	C9			1:181		xch A, r1				; save Acc to r1
0105	EB			1:182		mov A, r3				; load low byte of target value to A
0106	F6			1:183		mov @r0, A 				; save low byte of variable to r1
0107	EA			1:184		mov A, r2				; load high byte of target value to A
0108	08			1:185		inc r0					; increment r0 to high byte of variable address
0109	F6			1:186		mov @r0, A 				; save high byte of variable to r0
010A	C9			1:187		xch A, r1				; restore Acc from r1
010B	22			1:188		ret
				1:189		
				1:190	; the address of LE 16bit integer is stored in DPTR
010C				1:191	DecrementWord:
010C	12	01	19	1:192		lcall LoadVariable 		; load address of variable to r0
010F	E6			1:193		mov A, @r0				; load low byte of variable to A
0110	14			1:194		dec A					; decrement low byte of variable
0111	F6			1:195		mov @r0, A				; save low byte of variable
0112	64	FF		1:196		xrl A, #FFh				; check if A is 255 (0xFF)
0114	70	02		1:197		jnz __DecrementWord_End	; if not, jump to end (no underflow)
0116	08			1:198		inc r0					; set r0 to high byte of variable address
0117	16			1:199		dec @r0					; decrement high byte of variable
0118				1:200	__DecrementWord_End:
0118	22			1:201		ret
				1:202	
				1:203	; loads the variable address from memory to the return register r0
0119				1:204	LoadVariable:
0119	C9			1:205		xch A, r1 		; save Acc to r1
011A	E4			1:206		clr A			; wipe Acc
011B	93			1:207		movc A, @A+DPTR	; load variable address from memory
011C	C8			1:208		xch A, r0		; save variable address to return register r0 
011D	C9			1:209		xch A, r1		; restore Acc from r1
011E	22			1:210		ret
				1:211	
011F				1:212	_seconds:
011F	32	1:213		db 32h
0120				1:214	_clock_ticks:
0120	33	1:215		db 33h ; 16 bit integer starting at RAM addr 0x33
0121				1:216	_pointer: 
0121	4B	1:217		db 4Bh ; 16 bit integer pointing from 40h to 49h
0122				1:218	_array:
0122	40	1:219		db 40h 
0123				1:220	_average:
0123	4A	1:221		db 4Ah ; 16 bit integer average of all 10 temperature measurements
0124				1:222	_average2:
0124	4C	1:223		db 4Ch
				1:224	
				1:225	

 225 Zeilen übersetzt. Code Ende bei 0125h.
 19 Labels:
	Initialisierung: 000Dh
	OnTick: 0054h
	__OnTick_End: 0065h
	DoAfterTenSeconds: 006Ch
	__DoAfterTenSeconds_End: 0081h
	CalculateAverage: 0084h
	CompareAverages: 00E7h
	__CompareAverages_Zero: 00F2h
	ResetClockTicks: 00F6h
	SetWord: 0101h
	DecrementWord: 010Ch
	__DecrementWord_End: 0118h
	LoadVariable: 0119h
	_seconds: 011Fh
	_clock_ticks: 0120h
	_pointer: 0121h
	_array: 0122h
	_average: 0123h
	_average2: 0124h

